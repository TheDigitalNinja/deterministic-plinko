<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plinko Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background-color: #1a1a2e;
            font-family: Arial, sans-serif;
            color: #fff;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 800px;
        }

        .controls {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            width: 100%;
        }

        .bucket-buttons {
            display: flex;
            justify-content: space-around;
            width: 100%;
            margin-bottom: 20px;
        }

        button {
            background-color: #4a4e69;
            color: white;
            border: none;
            padding: 10px 15px;
            margin: 0 5px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #6a6d91;
        }

        button.selected {
            background-color: #f72585;
        }

        canvas {
            border: 2px solid #f72585;
            background-color: #16213e;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>Plinko Game</h1>
        
        <div class="bucket-buttons">
            <button id="bucket1">1</button>
            <button id="bucket2">2</button>
            <button id="bucket3">3</button>
            <button id="bucket4">4</button>
            <button id="bucket5">5</button>
            <button id="random">Random</button>
        </div>
        
        <div class="controls">
            <button id="drop">Drop Ball</button>
            <button id="reset">Reset</button>
        </div>
        
        <canvas id="plinkoCanvas"></canvas>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Game constants
            const canvas = document.getElementById('plinkoCanvas');
            const ctx = canvas.getContext('2d');
            const bucketButtons = document.querySelectorAll('.bucket-buttons button');
            const dropButton = document.getElementById('drop');
            const resetButton = document.getElementById('reset');
            
            // Game configuration
            const GAME_CONFIG = {
                // Peg configuration
                pegRadius: 6,
                pegColor: '#f8f9fa',
                pegRows: 12,           // Number of rows of pegs
                pegSpacing: 50,        // Horizontal spacing between pegs
                pegOffset: 25,         // Additional stagger offset
                pegGlowIntensity: 0.3, // Intensity of peg glow effect
                pegHeatmap: false,     // Whether to use heatmap visualization
                pegInfluenceRadius: 80, // How far a peg's path influence extends
                
                // Path influence zones
                pathZones: [
                    // Zones are defined by start/end rows and preferred direction 
                    // direction: -1=left, 0=neutral, 1=right
                    { startRow: 0, endRow: 4, direction: 0, strength: 0.5 },
                    { startRow: 5, endRow: 8, direction: 0, strength: 0.7 },
                    { startRow: 9, endRow: 12, direction: 0, strength: 1.0 }
                ],
                
                // Ball configuration
                ballRadius: 10,
                ballColor: '#f72585',
                ballTrailLength: 5,
                ballRestitution: 0.85, // Bounciness factor
                
                // Physics
                backgroundColor: '#16213e',
                bucketCount: 5,
                gravity: 0.3,
                speedDamping: 0.95,    // Speed loss on wall collision
                
                // Path control
                pathControlStrength: 0.25, // Base strength of guidance (0-1)
                pathControlRamp: 0.03,     // How much control increases as ball descends
                pathRandomness: 0.3        // Random factor in ball movement (0-1)
            };
            
            // Game state
            let selectedBucket = null;
            let isGameActive = false;
            let animationFrameId = null;
            let lastTimestamp = 0;
            let deltaTime = 0;
            let pegLocations = [];
            let pegInfluenceMap = {};
            let bucketLocations = [];
            let ball = null;
            let ballTrail = [];
            let collisionHistory = [];
            let targetBucket = null;
            let pegPathData = {}; // Stores peg guidance data for visualization
            
            // Resize the canvas to maintain proper size and aspect ratio
            function resizeCanvas() {
                const containerWidth = document.querySelector('.game-container').offsetWidth;
                const maxWidth = 800;
                const width = Math.min(containerWidth - 20, maxWidth);
                const height = width * 1.5;
                
                canvas.width = width;
                canvas.height = height;
                
                // Recalculate game dimensions based on canvas size
                GAME_CONFIG.pegSpacing = Math.floor(width / 16);
                GAME_CONFIG.pegRadius = Math.floor(width / 100);
                GAME_CONFIG.ballRadius = Math.floor(width / 60);
                
                // Regenerate pegs and buckets for new canvas size
                initPegs();
                initBuckets();
                
                // Redraw if necessary
                if (!isGameActive) {
                    drawGame();
                }
            }
            
            // Get influence strength for a peg based on its row
            function getPegZoneInfluence(row) {
                for (const zone of GAME_CONFIG.pathZones) {
                    if (row >= zone.startRow && row <= zone.endRow) {
                        return {
                            direction: zone.direction,
                            strength: zone.strength
                        };
                    }
                }
                return { direction: 0, strength: 0.5 }; // Default if no zone matches
            }
            
            // Calculate peg influence value for guiding ball to target bucket
            function calculatePegInfluence(pegIndex, targetBucketNum) {
                const peg = pegLocations[pegIndex];
                const targetBucket = bucketLocations[targetBucketNum - 1];
                
                // Calculate horizontal distance to bucket
                const dx = targetBucket.x - peg.x;
                
                // Get the row number - we need to know how far down the board we are
                let rowIndex = 0;
                for (let i = 0; i < pegIndex; i++) {
                    if (pegLocations[i].y < peg.y && 
                        Math.abs(pegLocations[i].y - peg.y) < GAME_CONFIG.pegSpacing) {
                        rowIndex++;
                        break;
                    }
                }
                
                // Get the zone influence
                const zoneInfo = getPegZoneInfluence(rowIndex);
                
                // Calculate influence strength based on distance and zone
                const distanceRatio = Math.abs(dx) / canvas.width;
                const directionBias = Math.sign(dx);
                
                // Direction bias: +1 means peg should influence ball to go right
                // Direction bias: -1 means peg should influence ball to go left
                const influenceDirection = directionBias;
                
                return {
                    direction: influenceDirection,
                    strength: zoneInfo.strength * (1 - distanceRatio * 0.5)
                };
            }
            
            // Initialize the influence map for each peg for each target bucket
            function initPegInfluenceMap() {
                pegInfluenceMap = {};
                
                // For each target bucket
                for (let bucketNum = 1; bucketNum <= GAME_CONFIG.bucketCount; bucketNum++) {
                    pegInfluenceMap[bucketNum] = [];
                    
                    // Calculate influence for each peg
                    for (let pegIndex = 0; pegIndex < pegLocations.length; pegIndex++) {
                        pegInfluenceMap[bucketNum][pegIndex] = calculatePegInfluence(pegIndex, bucketNum);
                    }
                }
            }
            
            // Generate peg display data for visualization
            function generatePegPathData() {
                pegPathData = {};
                
                if (!targetBucket) return;
                
                const bucketInfluenceMap = pegInfluenceMap[targetBucket];
                if (!bucketInfluenceMap) return;
                
                // Store the data keyed by peg index
                for (let i = 0; i < pegLocations.length; i++) {
                    pegPathData[i] = {
                        influence: bucketInfluenceMap[i],
                        isActive: false,  // Will be set to true when ball is near
                        activationTime: 0 // For animation effects
                    };
                }
            }
            
            // Initialize peg positions in a triangular grid with influence for path guidance
            function initPegs() {
                pegLocations = [];
                const startX = canvas.width / 2;
                const startY = canvas.height * 0.15;
                const horizontalSpacing = GAME_CONFIG.pegSpacing;
                const verticalSpacing = GAME_CONFIG.pegSpacing * 0.866; // approx. sqrt(3)/2
                
                // Generate peg positions in staggered rows (triangular grid)
                for (let row = 0; row < GAME_CONFIG.pegRows; row++) {
                    const pegsInRow = row + 5;
                    const rowWidth = (pegsInRow - 1) * horizontalSpacing;
                    const rowStartX = startX - rowWidth / 2;
                    
                    // Offset every other row for triangular pattern
                    const xOffset = (row % 2 === 0) ? 0 : horizontalSpacing / 2;
                    
                    for (let col = 0; col < pegsInRow; col++) {
                        // Create peg with position, visual, and physics properties
                        pegLocations.push({
                            x: rowStartX + col * horizontalSpacing + xOffset,
                            y: startY + row * verticalSpacing,
                            radius: GAME_CONFIG.pegRadius,
                            row: row,
                            col: col,
                            // For visualization and effects
                            glowIntensity: GAME_CONFIG.pegGlowIntensity,
                            // For debugging
                            influenceDirection: 0,
                            influenceStrength: 0
                        });
                    }
                }
                
                // Initialize the influence map
                initPegInfluenceMap();
            }
            
            // Initialize bucket positions
            function initBuckets() {
                bucketLocations = [];
                const bucketWidth = canvas.width / (GAME_CONFIG.bucketCount + 1);
                const bucketY = canvas.height * 0.9;
                const bucketHeight = canvas.height * 0.1;
                
                for (let i = 0; i < GAME_CONFIG.bucketCount; i++) {
                    bucketLocations.push({
                        x: (i + 1) * bucketWidth,
                        y: bucketY,
                        width: bucketWidth,
                        height: bucketHeight,
                        number: i + 1
                    });
                }
            }
            
            // Draw background with gradient
            function drawBackground() {
                // Create gradient
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#0f172a');
                gradient.addColorStop(1, '#1e293b');
                
                // Fill background
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw grid lines for visual effect
                ctx.strokeStyle = 'rgba(248, 249, 250, 0.05)';
                ctx.lineWidth = 1;
                
                // Vertical lines
                const lineSpacing = canvas.width / 20;
                for (let x = 0; x < canvas.width; x += lineSpacing) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                
                // Horizontal lines
                for (let y = 0; y < canvas.height; y += lineSpacing) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
            }
            
            // Get color for a peg based on its influence
            function getPegColor(pegIndex) {
                // Default color if no guidance is active
                if (!targetBucket || !pegPathData[pegIndex]) {
                    return GAME_CONFIG.pegColor;
                }
                
                const pegInfo = pegPathData[pegIndex];
                
                // If heatmap visualization is enabled, show directional influence
                if (GAME_CONFIG.pegHeatmap && pegInfo.isActive) {
                    const influence = pegInfo.influence;
                    
                    // Direction: -1 (left/blue) to 0 (neutral/white) to 1 (right/red)
                    if (influence.direction < 0) {
                        // Blue for leftward influence
                        const intensity = Math.abs(influence.strength * 255);
                        return `rgb(255, ${255 - intensity * 0.7}, ${255 - intensity})`;
                    } else if (influence.direction > 0) {
                        // Red for rightward influence
                        const intensity = Math.abs(influence.strength * 255);
                        return `rgb(${255}, ${255 - intensity * 0.7}, ${255 - intensity})`;
                    } 
                    
                    // White for neutral
                    return '#ffffff';
                }
                
                // Standard color with no heatmap
                return GAME_CONFIG.pegColor;
            }
            
            // Check if a peg is active (ball is nearby)
            function updateActivePegs() {
                if (!ball || !pegPathData) return;
                
                // Update active state of pegs based on ball proximity
                for (let i = 0; i < pegLocations.length; i++) {
                    const peg = pegLocations[i];
                    const pegData = pegPathData[i];
                    
                    if (!pegData) continue;
                    
                    // Calculate distance from ball to peg
                    const dx = ball.x - peg.x;
                    const dy = ball.y - peg.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Activate pegs within influence radius
                    pegData.isActive = distance < GAME_CONFIG.pegInfluenceRadius;
                    
                    // Set activation time for animation
                    if (pegData.isActive && pegData.activationTime === 0) {
                        pegData.activationTime = Date.now();
                    } else if (!pegData.isActive) {
                        pegData.activationTime = 0;
                    }
                }
            }
            
            // Draw all pegs with influence visualization
            function drawPegs() {
                // Update active pegs if ball exists
                if (ball) {
                    updateActivePegs();
                }
                
                // Draw each peg
                pegLocations.forEach((peg, index) => {
                    // Get the peg color based on influence
                    const pegColor = getPegColor(index);
                    
                    // Draw the peg body
                    ctx.beginPath();
                    ctx.arc(peg.x, peg.y, peg.radius, 0, Math.PI * 2);
                    ctx.fillStyle = pegColor;
                    ctx.fill();
                    
                    // Add outer stroke
                    ctx.beginPath();
                    ctx.arc(peg.x, peg.y, peg.radius, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // Add glow effect
                    let glowIntensity = peg.glowIntensity;
                    
                    // Enhanced glow for active pegs
                    const pegData = pegPathData[index];
                    if (pegData && pegData.isActive) {
                        // Pulse effect based on activation time
                        const elapsed = Date.now() - pegData.activationTime;
                        const pulseIntensity = 0.3 + 0.2 * Math.sin(elapsed / 200); // Oscillating intensity
                        glowIntensity = Math.max(glowIntensity, pulseIntensity);
                    }
                    
                    // Draw the glow
                    ctx.beginPath();
                    ctx.arc(peg.x, peg.y, peg.radius * 1.8, 0, Math.PI * 2);
                    
                    // Create radial gradient for glow effect
                    const glowGradient = ctx.createRadialGradient(
                        peg.x, peg.y, peg.radius * 0.5,
                        peg.x, peg.y, peg.radius * 1.8
                    );
                    
                    // Adjust color based on influence if needed
                    let glowColor = 'rgba(248, 249, 250, ';
                    if (pegData && pegData.isActive && GAME_CONFIG.pegHeatmap) {
                        const influence = pegData.influence;
                        if (influence.direction < 0) {
                            glowColor = 'rgba(100, 150, 255, '; // Blue for left
                        } else if (influence.direction > 0) {
                            glowColor = 'rgba(255, 100, 100, '; // Red for right
                        }
                    }
                    
                    glowGradient.addColorStop(0, glowColor + glowIntensity + ')');
                    glowGradient.addColorStop(1, glowColor + '0)');
                    
                    ctx.fillStyle = glowGradient;
                    ctx.fill();
                    
                    // Draw influence direction indicators (optional for debugging)
                    if (GAME_CONFIG.pegHeatmap && pegData && pegData.isActive) {
                        const influence = pegData.influence;
                        
                        if (influence.direction !== 0) {
                            // Draw direction indicator
                            const arrowLength = peg.radius * 2 * influence.strength;
                            const arrowX = peg.x + arrowLength * influence.direction;
                            
                            ctx.beginPath();
                            ctx.moveTo(peg.x, peg.y);
                            ctx.lineTo(arrowX, peg.y);
                            
                            ctx.strokeStyle = influence.direction < 0 ? 
                                'rgba(100, 150, 255, 0.7)' : 'rgba(255, 100, 100, 0.7)';
                            ctx.lineWidth = 2;
                            ctx.stroke();
                        }
                    }
                });
            }
            
            // Draw all buckets
            function drawBuckets() {
                bucketLocations.forEach((bucket, index) => {
                    // Draw bucket body
                    ctx.fillStyle = selectedBucket === index + 1 ? '#f72585' : '#4a4e69';
                    ctx.fillRect(bucket.x - bucket.width/2, bucket.y, bucket.width, bucket.height);
                    
                    // Draw bucket rim
                    ctx.fillStyle = '#6a6d91';
                    ctx.fillRect(bucket.x - bucket.width/2, bucket.y, bucket.width, 5);
                    
                    // Draw bucket number
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${Math.floor(bucket.width / 5)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.fillText(bucket.number.toString(), bucket.x, bucket.y + bucket.height / 2 + 8);
                });
            }
            
            // Draw the ball and its trail effects
            function drawBall() {
                if (!ball) return;
                
                // Draw ball trail for motion blur effect
                if (ballTrail.length > 0) {
                    for (let i = 0; i < ballTrail.length; i++) {
                        const trailPoint = ballTrail[i];
                        const alpha = 0.3 * (i / ballTrail.length);
                        const trailRadius = ball.radius * (0.7 + (i / ballTrail.length) * 0.3);
                        
                        ctx.beginPath();
                        ctx.arc(trailPoint.x, trailPoint.y, trailRadius, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(247, 37, 133, ${alpha})`;
                        ctx.fill();
                    }
                }
                
                // Draw ball itself with base color
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                ctx.fillStyle = ball.color;
                ctx.fill();
                
                // Add highlight effect without using gradient that might make it look white
                ctx.beginPath();
                const highlightRadius = ball.radius * 0.3;
                ctx.arc(ball.x - ball.radius * 0.3, ball.y - ball.radius * 0.3, highlightRadius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.fill();
                
                // Draw sparkle effect on recent collisions
                collisionHistory.forEach(collision => {
                    if (collision.age < 5) {
                        const sparkRadius = ball.radius * 0.8 * (1 - collision.age / 5);
                        const sparkAlpha = 0.8 * (1 - collision.age / 5);
                        
                        ctx.beginPath();
                        ctx.arc(collision.x, collision.y, sparkRadius, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(255, 255, 255, ${sparkAlpha})`;
                        ctx.fill();
                    }
                    collision.age++;
                });
                
                // Remove old collision effects
                collisionHistory = collisionHistory.filter(c => c.age <= 5);
            }
            
            // Add a position to the ball trail
            function updateBallTrail() {
                if (!ball) return;
                
                // Add current position to trail
                ballTrail.unshift({ x: ball.x, y: ball.y });
                
                // Limit trail length
                if (ballTrail.length > GAME_CONFIG.ballTrailLength) {
                    ballTrail.pop();
                }
            }
            
            // Check for collisions between ball and pegs
            function checkPegCollisions() {
                if (!ball) return;
                
                let hasCollided = false;
                
                for (const peg of pegLocations) {
                    // Calculate distance between ball and peg centers
                    const dx = ball.x - peg.x;
                    const dy = ball.y - peg.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Check if collision occurred
                    const minDistance = ball.radius + peg.radius;
                    if (distance < minDistance) {
                        hasCollided = true;
                        
                        // Calculate collision response
                        const angle = Math.atan2(dy, dx);
                        
                        // Move ball outside of collision more forcefully
                        const overlap = minDistance - distance + 1; // Add 1px extra to prevent sticking
                        ball.x += Math.cos(angle) * overlap;
                        ball.y += Math.sin(angle) * overlap;
                        
                        // Calculate new velocity after bounce
                        const speed = Math.sqrt(ball.velocityX * ball.velocityX + ball.velocityY * ball.velocityY);
                        const incomingAngle = Math.atan2(ball.velocityY, ball.velocityX);
                        const reflectionAngle = 2 * angle - incomingAngle;
                        
                        // Add randomness to reflection
                        const randomFactor = (Math.random() - 0.5) * GAME_CONFIG.pathRandomness;
                        const finalAngle = reflectionAngle + randomFactor;
                        
                        // Set new velocity with higher minimum speed guarantee
                        const newSpeed = Math.max(speed * GAME_CONFIG.ballRestitution, 3.0);
                        ball.velocityX = Math.cos(finalAngle) * newSpeed;
                        ball.velocityY = Math.sin(finalAngle) * newSpeed;
                        
                        // Add a minimum vertical velocity to prevent horizontal sticking
                        if (Math.abs(ball.velocityY) < 0.5) {
                            const verticalBoost = Math.random() * 0.5 + 0.5; // 0.5 to 1.0
                            ball.velocityY += ball.velocityY >= 0 ? verticalBoost : -verticalBoost;
                        }
                        
                        // Add to collision history for visual effects
                        collisionHistory.push({
                            x: ball.x,
                            y: ball.y,
                            age: 0
                        });
                        
                        // Small audio feedback could be added here
                    }
                }
            }
            
            // Check if ball landed in a bucket
            function checkBucketLanding() {
                if (!ball) return false;
                
                // Only check when ball is in the lower part of the screen
                if (ball.y < canvas.height * 0.85) return false;
                
                for (let i = 0; i < bucketLocations.length; i++) {
                    const bucket = bucketLocations[i];
                    
                    // Check if ball is within bucket boundaries
                    if (
                        ball.x > bucket.x - bucket.width/2 &&
                        ball.x < bucket.x + bucket.width/2 &&
                        ball.y > bucket.y &&
                        ball.y < bucket.y + bucket.height
                    ) {
                        // Ball landed in a bucket
                        const landedInTargetBucket = (i + 1) === targetBucket;
                        
                        // Visual feedback for landing
                        ball.velocityX = 0;
                        ball.velocityY = 0;
                        
                        // Create a burst of collision effects
                        for (let j = 0; j < 10; j++) {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = Math.random() * bucket.width * 0.3;
                            collisionHistory.push({
                                x: ball.x + Math.cos(angle) * distance,
                                y: ball.y + Math.sin(angle) * distance,
                                age: Math.floor(Math.random() * 3)
                            });
                        }
                        
                        // End game after a short delay
                        setTimeout(() => {
                            isGameActive = false;
                            dropButton.disabled = false;
                            cancelAnimationFrame(animationFrameId);
                            
                            // Show result notification - this could be enhanced
                            if (landedInTargetBucket) {
                                console.log('Ball landed in the target bucket!');
                            } else {
                                console.log(`Ball landed in bucket ${i+1} instead of ${targetBucket}`);
                            }
                        }, 500);
                        
                        return true;
                    }
                }
                
                return false;
            }
            
            // Calculate peg influence on ball at current position
            function calculateCurrentPegInfluence() {
                if (!ball || !targetBucket || !pegPathData) return { x: 0, y: 0 };
                
                let totalInfluenceX = 0;
                let totalInfluenceY = 0;
                let totalWeight = 0;
                
                // Check each peg's influence
                for (let i = 0; i < pegLocations.length; i++) {
                    const peg = pegLocations[i];
                    const pegData = pegPathData[i];
                    
                    if (!pegData) continue;
                    
                    // Calculate distance from ball to peg
                    const dx = ball.x - peg.x;
                    const dy = ball.y - peg.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Skip pegs that are too far away
                    if (distance > GAME_CONFIG.pegInfluenceRadius) continue;
                    
                    // Calculate influence weight based on distance (closer = stronger influence)
                    const weight = 1 - (distance / GAME_CONFIG.pegInfluenceRadius);
                    const influence = pegData.influence;
                    
                    // Add weighted influence to total
                    totalInfluenceX += influence.direction * influence.strength * weight;
                    totalWeight += weight;
                    
                    // Mark this peg as active for visualization
                    pegData.isActive = true;
                    if (pegData.activationTime === 0) {
                        pegData.activationTime = Date.now();
                    }
                }
                
                // Normalize influence
                if (totalWeight > 0) {
                    return {
                        x: totalInfluenceX / totalWeight,
                        y: 0  // For now, only horizontal influence
                    };
                }
                
                return { x: 0, y: 0 };
            }
            
            // Apply guidance to direct the ball towards the target bucket
            function guideBallPath() {
                if (!ball || !targetBucket || !isGameActive) return;
                
                // Get target bucket
                const target = bucketLocations[targetBucket - 1];
                
                // Calculate direct influence - pulling toward target bucket
                const dx = target.x - ball.x;
                
                // Calculate guidance strength based on vertical position (increases as ball falls)
                const verticalProgress = (ball.y / canvas.height);
                let guidanceStrength = GAME_CONFIG.pathControlStrength + 
                                     (verticalProgress * GAME_CONFIG.pathControlRamp);
                                     
                // Cap direct guidance strength
                guidanceStrength = Math.min(guidanceStrength, 0.8);
                
                // Apply direct guidance - pull toward bucket
                const directInfluence = dx * 0.0005 * guidanceStrength * deltaTime;
                
                // Get peg-based influence - guidance through the peg field
                const pegInfluence = calculateCurrentPegInfluence();
                const pegFactor = 0.02 * deltaTime; // Adjust strength of peg influence
                
                // Combine both influences
                ball.velocityX += directInfluence + (pegInfluence.x * pegFactor);
                
                // Add small random variations to make movement look natural
                const randomX = (Math.random() - 0.5) * 0.05 * GAME_CONFIG.pathRandomness;
                ball.velocityX += randomX;
                
                // Add a minimum velocity check to prevent the ball from moving too slowly
                const currentSpeed = Math.sqrt(ball.velocityX * ball.velocityX + ball.velocityY * ball.velocityY);
                if (currentSpeed < 1.5) {
                    // Scale up the velocity while preserving direction
                    const factor = 1.5 / currentSpeed;
                    ball.velocityX *= factor;
                    ball.velocityY *= factor;
                }
            }
            
            // Update ball physics
            function updateBall(deltaTime) {
                if (!ball || !isGameActive) return;
                
                // Update ball trail
                updateBallTrail();
                
                // Apply guidance toward target bucket
                guideBallPath();
                
                // Apply gravity
                ball.velocityY += GAME_CONFIG.gravity * deltaTime;
                
                // Update position based on velocity
                ball.x += ball.velocityX * deltaTime;
                ball.y += ball.velocityY * deltaTime;
                
                // Check for collisions with pegs
                checkPegCollisions();
                
                // Check if ball landed in a bucket
                if (checkBucketLanding()) {
                    return; // Ball landed, stop physics updates
                }
                
                // Handle wall collisions
                if (ball.x - ball.radius < 0) {
                    ball.x = ball.radius;
                    ball.velocityX = -ball.velocityX * GAME_CONFIG.speedDamping;
                    collisionHistory.push({ x: ball.x, y: ball.y, age: 0 });
                } else if (ball.x + ball.radius > canvas.width) {
                    ball.x = canvas.width - ball.radius;
                    ball.velocityX = -ball.velocityX * GAME_CONFIG.speedDamping;
                    collisionHistory.push({ x: ball.x, y: ball.y, age: 0 });
                }
                
                // Check if ball fell out of bounds
                if (ball.y - ball.radius > canvas.height) {
                    // Reset game state
                    isGameActive = false;
                    dropButton.disabled = false;
                    cancelAnimationFrame(animationFrameId);
                }
            }
            
            // Set up initial game state
            function initGame() {
                resizeCanvas();
                initPegs();
                initBuckets();
                addEventListeners();
                drawGame();
            }
            
            // Get initial ball position for reaching target bucket
            function calculateInitialBallPosition() {
                // Target bucket to aim for
                if (targetBucket === null) {
                    throw new Error("Target bucket is not set");
                }
                
                // Base position in the center
                let xPos = canvas.width / 2;
                
                // Calculate small offset based on target bucket
                // This gives the ball a slight initial bias toward the target
                const bucketOffset = targetBucket - Math.ceil(GAME_CONFIG.bucketCount / 2);
                const maxOffset = canvas.width * 0.05; // 5% of canvas width max
                const initialOffset = bucketOffset * (maxOffset / Math.ceil(GAME_CONFIG.bucketCount / 2));
                
                // Add small randomness to make it look natural
                const randomFactor = (Math.random() - 0.5) * (canvas.width * 0.02);
                xPos += initialOffset + randomFactor;
                
                // Ensure within bounds
                xPos = Math.max(GAME_CONFIG.ballRadius, Math.min(canvas.width - GAME_CONFIG.ballRadius, xPos));
                
                return xPos;
            }
            
            // Create the ball at the top of the screen
            function createBall() {
                // Clear previous state
                ballTrail = [];
                collisionHistory = [];
                
                // If random mode is selected, choose a random bucket
                if (selectedBucket === 'random') {
                    targetBucket = Math.floor(Math.random() * GAME_CONFIG.bucketCount) + 1;
                } else {
                    targetBucket = selectedBucket;
                }
                
                // Generate peg path data for the selected target bucket
                generatePegPathData();
                
                // Calculate starting position
                const initialX = calculateInitialBallPosition();
                
                // Create ball with initial velocity
                ball = {
                    x: initialX,
                    y: canvas.height * 0.05,
                    radius: GAME_CONFIG.ballRadius,
                    color: GAME_CONFIG.ballColor,
                    velocityX: (Math.random() - 0.5) * 1.5, // Increased initial velocity
                    velocityY: 1.0, // Add initial downward velocity
                    // Track additional state
                    targetBucket: targetBucket,
                    collisionCount: 0,
                    // For visual effects
                    rotation: 0,
                    rotationSpeed: (Math.random() - 0.5) * 0.2
                };
            }
            
            // Reset the ball to the top of the screen
            function resetBall() {
                ball = null;
                ballTrail = [];
                collisionHistory = [];
                targetBucket = null;
                isGameActive = false;
                dropButton.disabled = false;
                
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                
                drawGame();
            }
            
            // Draw the game elements on the canvas
            function drawGame() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                drawBackground();
                drawPegs();
                drawBuckets();
                drawBall();
            }
            
            // Game loop with timestamp for smooth animation
            function gameLoop(timestamp) {
                if (!lastTimestamp) {
                    lastTimestamp = timestamp;
                }
                
                // Calculate time difference between frames
                deltaTime = (timestamp - lastTimestamp) / 16; // Normalize to ~60fps
                lastTimestamp = timestamp;
                
                // Update game physics
                updateBall(deltaTime);
                
                // Draw everything
                drawGame();
                
                // Continue the loop if game is active
                if (isGameActive) {
                    animationFrameId = requestAnimationFrame(gameLoop);
                }
            }
            
            // Event handlers
            function handleBucketSelection(event) {
                if (isGameActive) return;
                
                bucketButtons.forEach(btn => btn.classList.remove('selected'));
                event.target.classList.add('selected');
                
                if (event.target.id === 'random') {
                    selectedBucket = 'random';
                } else {
                    selectedBucket = parseInt(event.target.textContent);
                }
                
                drawGame();
            }
            
            function handleDropBall() {
                if (isGameActive || selectedBucket === null) return;
                
                isGameActive = true;
                dropButton.disabled = true;
                lastTimestamp = 0;
                
                // Initialize ball and start game loop
                createBall();
                animationFrameId = requestAnimationFrame(gameLoop);
            }
            
            function handleReset() {
                resetBall();
            }
            
            function addEventListeners() {
                // Add event listeners
                bucketButtons.forEach(btn => {
                    btn.addEventListener('click', handleBucketSelection);
                });
                
                dropButton.addEventListener('click', handleDropBall);
                resetButton.addEventListener('click', handleReset);
                window.addEventListener('resize', resizeCanvas);
            }
            
            // Initialize the game
            initGame();
        });
    </script>
</body>
</html>