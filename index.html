<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plinko Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background-color: #1a1a2e;
            font-family: Arial, sans-serif;
            color: #fff;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 800px;
        }

        .controls {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            width: 100%;
        }

        .bucket-buttons {
            display: flex;
            justify-content: space-around;
            width: 100%;
            margin-bottom: 20px;
        }

        button {
            background-color: #4a4e69;
            color: white;
            border: none;
            padding: 10px 15px;
            margin: 0 5px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #6a6d91;
        }

        button.selected {
            background-color: #f72585;
        }

        canvas {
            border: 2px solid #f72585;
            background-color: #16213e;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>Plinko Game</h1>
        
        <div class="bucket-buttons">
            <button id="bucket1">1</button>
            <button id="bucket2">2</button>
            <button id="bucket3">3</button>
            <button id="bucket4">4</button>
            <button id="bucket5">5</button>
            <button id="random">Random</button>
        </div>
        
        <div class="controls">
            <button id="drop">Drop Ball</button>
            <button id="reset">Reset</button>
        </div>
        
        <canvas id="plinkoCanvas"></canvas>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Game constants
            const canvas = document.getElementById('plinkoCanvas');
            const ctx = canvas.getContext('2d');
            const bucketButtons = document.querySelectorAll('.bucket-buttons button');
            const dropButton = document.getElementById('drop');
            const resetButton = document.getElementById('reset');
            
            // Game configuration
            const GAME_CONFIG = {
                pegRadius: 6,
                pegColor: '#f8f9fa',
                pegRows: 12,
                pegSpacing: 50,
                pegOffset: 25,
                ballRadius: 10,
                ballColor: '#f72585',
                ballTrailLength: 5,
                ballRestitution: 0.85,    // Increased bounciness factor
                backgroundColor: '#16213e',
                bucketCount: 5,
                gravity: 0.3,             // Increased gravity
                speedDamping: 0.95,       // Less speed loss on wall collision
                pathControlStrength: 0.25, // Strength of path guidance (0-1)
                pathControlRamp: 0.03,    // How much control increases as ball descends
                pathRandomness: 0.3       // Random factor in ball movement (0-1)
            };
            
            // Game state
            let selectedBucket = null;
            let isGameActive = false;
            let animationFrameId = null;
            let lastTimestamp = 0;
            let deltaTime = 0;
            let pegLocations = [];
            let bucketLocations = [];
            let ball = null;
            let ballTrail = [];
            let collisionHistory = [];
            let targetBucket = null;
            
            // Resize the canvas to maintain proper size and aspect ratio
            function resizeCanvas() {
                const containerWidth = document.querySelector('.game-container').offsetWidth;
                const maxWidth = 800;
                const width = Math.min(containerWidth - 20, maxWidth);
                const height = width * 1.5;
                
                canvas.width = width;
                canvas.height = height;
                
                // Recalculate game dimensions based on canvas size
                GAME_CONFIG.pegSpacing = Math.floor(width / 16);
                GAME_CONFIG.pegRadius = Math.floor(width / 100);
                GAME_CONFIG.ballRadius = Math.floor(width / 60);
                
                // Regenerate pegs and buckets for new canvas size
                initPegs();
                initBuckets();
                
                // Redraw if necessary
                if (!isGameActive) {
                    drawGame();
                }
            }
            
            // Initialize peg positions in a triangular grid
            function initPegs() {
                pegLocations = [];
                const startX = canvas.width / 2;
                const startY = canvas.height * 0.15;
                const horizontalSpacing = GAME_CONFIG.pegSpacing;
                const verticalSpacing = GAME_CONFIG.pegSpacing * 0.866; // approx. sqrt(3)/2
                
                for (let row = 0; row < GAME_CONFIG.pegRows; row++) {
                    const pegsInRow = row + 5;
                    const rowWidth = (pegsInRow - 1) * horizontalSpacing;
                    const rowStartX = startX - rowWidth / 2;
                    
                    for (let col = 0; col < pegsInRow; col++) {
                        pegLocations.push({
                            x: rowStartX + col * horizontalSpacing,
                            y: startY + row * verticalSpacing,
                            radius: GAME_CONFIG.pegRadius
                        });
                    }
                }
            }
            
            // Initialize bucket positions
            function initBuckets() {
                bucketLocations = [];
                const bucketWidth = canvas.width / (GAME_CONFIG.bucketCount + 1);
                const bucketY = canvas.height * 0.9;
                const bucketHeight = canvas.height * 0.1;
                
                for (let i = 0; i < GAME_CONFIG.bucketCount; i++) {
                    bucketLocations.push({
                        x: (i + 1) * bucketWidth,
                        y: bucketY,
                        width: bucketWidth,
                        height: bucketHeight,
                        number: i + 1
                    });
                }
            }
            
            // Draw background with gradient
            function drawBackground() {
                // Create gradient
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#0f172a');
                gradient.addColorStop(1, '#1e293b');
                
                // Fill background
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw grid lines for visual effect
                ctx.strokeStyle = 'rgba(248, 249, 250, 0.05)';
                ctx.lineWidth = 1;
                
                // Vertical lines
                const lineSpacing = canvas.width / 20;
                for (let x = 0; x < canvas.width; x += lineSpacing) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                
                // Horizontal lines
                for (let y = 0; y < canvas.height; y += lineSpacing) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
            }
            
            // Draw all pegs
            function drawPegs() {
                pegLocations.forEach(peg => {
                    ctx.beginPath();
                    ctx.arc(peg.x, peg.y, peg.radius, 0, Math.PI * 2);
                    ctx.fillStyle = GAME_CONFIG.pegColor;
                    ctx.fill();
                    
                    // Add subtle glow effect
                    ctx.beginPath();
                    ctx.arc(peg.x, peg.y, peg.radius * 1.5, 0, Math.PI * 2);
                    const glowGradient = ctx.createRadialGradient(
                        peg.x, peg.y, peg.radius * 0.5,
                        peg.x, peg.y, peg.radius * 1.5
                    );
                    glowGradient.addColorStop(0, 'rgba(248, 249, 250, 0.3)');
                    glowGradient.addColorStop(1, 'rgba(248, 249, 250, 0)');
                    ctx.fillStyle = glowGradient;
                    ctx.fill();
                });
            }
            
            // Draw all buckets
            function drawBuckets() {
                bucketLocations.forEach((bucket, index) => {
                    // Draw bucket body
                    ctx.fillStyle = selectedBucket === index + 1 ? '#f72585' : '#4a4e69';
                    ctx.fillRect(bucket.x - bucket.width/2, bucket.y, bucket.width, bucket.height);
                    
                    // Draw bucket rim
                    ctx.fillStyle = '#6a6d91';
                    ctx.fillRect(bucket.x - bucket.width/2, bucket.y, bucket.width, 5);
                    
                    // Draw bucket number
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${Math.floor(bucket.width / 5)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.fillText(bucket.number.toString(), bucket.x, bucket.y + bucket.height / 2 + 8);
                });
            }
            
            // Draw the ball and its trail effects
            function drawBall() {
                if (!ball) return;
                
                // Draw ball trail for motion blur effect
                if (ballTrail.length > 0) {
                    for (let i = 0; i < ballTrail.length; i++) {
                        const trailPoint = ballTrail[i];
                        const alpha = 0.3 * (i / ballTrail.length);
                        const trailRadius = ball.radius * (0.7 + (i / ballTrail.length) * 0.3);
                        
                        ctx.beginPath();
                        ctx.arc(trailPoint.x, trailPoint.y, trailRadius, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(247, 37, 133, ${alpha})`;
                        ctx.fill();
                    }
                }
                
                // Draw ball itself with base color
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                ctx.fillStyle = ball.color;
                ctx.fill();
                
                // Add highlight effect without using gradient that might make it look white
                ctx.beginPath();
                const highlightRadius = ball.radius * 0.3;
                ctx.arc(ball.x - ball.radius * 0.3, ball.y - ball.radius * 0.3, highlightRadius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.fill();
                
                // Draw sparkle effect on recent collisions
                collisionHistory.forEach(collision => {
                    if (collision.age < 5) {
                        const sparkRadius = ball.radius * 0.8 * (1 - collision.age / 5);
                        const sparkAlpha = 0.8 * (1 - collision.age / 5);
                        
                        ctx.beginPath();
                        ctx.arc(collision.x, collision.y, sparkRadius, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(255, 255, 255, ${sparkAlpha})`;
                        ctx.fill();
                    }
                    collision.age++;
                });
                
                // Remove old collision effects
                collisionHistory = collisionHistory.filter(c => c.age <= 5);
            }
            
            // Add a position to the ball trail
            function updateBallTrail() {
                if (!ball) return;
                
                // Add current position to trail
                ballTrail.unshift({ x: ball.x, y: ball.y });
                
                // Limit trail length
                if (ballTrail.length > GAME_CONFIG.ballTrailLength) {
                    ballTrail.pop();
                }
            }
            
            // Check for collisions between ball and pegs
            function checkPegCollisions() {
                if (!ball) return;
                
                let hasCollided = false;
                
                for (const peg of pegLocations) {
                    // Calculate distance between ball and peg centers
                    const dx = ball.x - peg.x;
                    const dy = ball.y - peg.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Check if collision occurred
                    const minDistance = ball.radius + peg.radius;
                    if (distance < minDistance) {
                        hasCollided = true;
                        
                        // Calculate collision response
                        const angle = Math.atan2(dy, dx);
                        
                        // Move ball outside of collision more forcefully
                        const overlap = minDistance - distance + 1; // Add 1px extra to prevent sticking
                        ball.x += Math.cos(angle) * overlap;
                        ball.y += Math.sin(angle) * overlap;
                        
                        // Calculate new velocity after bounce
                        const speed = Math.sqrt(ball.velocityX * ball.velocityX + ball.velocityY * ball.velocityY);
                        const incomingAngle = Math.atan2(ball.velocityY, ball.velocityX);
                        const reflectionAngle = 2 * angle - incomingAngle;
                        
                        // Add randomness to reflection
                        const randomFactor = (Math.random() - 0.5) * GAME_CONFIG.pathRandomness;
                        const finalAngle = reflectionAngle + randomFactor;
                        
                        // Set new velocity with higher minimum speed guarantee
                        const newSpeed = Math.max(speed * GAME_CONFIG.ballRestitution, 3.0);
                        ball.velocityX = Math.cos(finalAngle) * newSpeed;
                        ball.velocityY = Math.sin(finalAngle) * newSpeed;
                        
                        // Add a minimum vertical velocity to prevent horizontal sticking
                        if (Math.abs(ball.velocityY) < 0.5) {
                            const verticalBoost = Math.random() * 0.5 + 0.5; // 0.5 to 1.0
                            ball.velocityY += ball.velocityY >= 0 ? verticalBoost : -verticalBoost;
                        }
                        
                        // Add to collision history for visual effects
                        collisionHistory.push({
                            x: ball.x,
                            y: ball.y,
                            age: 0
                        });
                        
                        // Small audio feedback could be added here
                    }
                }
            }
            
            // Check if ball landed in a bucket
            function checkBucketLanding() {
                if (!ball) return false;
                
                // Only check when ball is in the lower part of the screen
                if (ball.y < canvas.height * 0.85) return false;
                
                for (let i = 0; i < bucketLocations.length; i++) {
                    const bucket = bucketLocations[i];
                    
                    // Check if ball is within bucket boundaries
                    if (
                        ball.x > bucket.x - bucket.width/2 &&
                        ball.x < bucket.x + bucket.width/2 &&
                        ball.y > bucket.y &&
                        ball.y < bucket.y + bucket.height
                    ) {
                        // Ball landed in a bucket
                        const landedInTargetBucket = (i + 1) === targetBucket;
                        
                        // Visual feedback for landing
                        ball.velocityX = 0;
                        ball.velocityY = 0;
                        
                        // Create a burst of collision effects
                        for (let j = 0; j < 10; j++) {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = Math.random() * bucket.width * 0.3;
                            collisionHistory.push({
                                x: ball.x + Math.cos(angle) * distance,
                                y: ball.y + Math.sin(angle) * distance,
                                age: Math.floor(Math.random() * 3)
                            });
                        }
                        
                        // End game after a short delay
                        setTimeout(() => {
                            isGameActive = false;
                            dropButton.disabled = false;
                            cancelAnimationFrame(animationFrameId);
                            
                            // Show result notification - this could be enhanced
                            if (landedInTargetBucket) {
                                console.log('Ball landed in the target bucket!');
                            } else {
                                console.log(`Ball landed in bucket ${i+1} instead of ${targetBucket}`);
                            }
                        }, 500);
                        
                        return true;
                    }
                }
                
                return false;
            }
            
            // Apply subtle guidance to direct the ball towards the target bucket
            function guideBallPath() {
                if (!ball || !targetBucket || !isGameActive) return;
                
                // Get target bucket
                const target = bucketLocations[targetBucket - 1];
                
                // Calculate horizontal distance to target
                const dx = target.x - ball.x;
                
                // Calculate guidance strength based on vertical position (increases as ball falls)
                const verticalProgress = (ball.y / canvas.height);
                let guidanceStrength = GAME_CONFIG.pathControlStrength + 
                                     (verticalProgress * GAME_CONFIG.pathControlRamp);
                                     
                // Cap guidance strength
                guidanceStrength = Math.min(guidanceStrength, 0.8);
                
                // Apply stronger horizontal force toward target bucket (increased from 0.0005 to 0.001)
                ball.velocityX += dx * 0.001 * guidanceStrength * deltaTime;
                
                // Add small random variations to make movement look natural
                const randomX = (Math.random() - 0.5) * 0.05 * GAME_CONFIG.pathRandomness;
                ball.velocityX += randomX;
                
                // Add a minimum velocity check to prevent the ball from moving too slowly
                const currentSpeed = Math.sqrt(ball.velocityX * ball.velocityX + ball.velocityY * ball.velocityY);
                if (currentSpeed < 1.5) {
                    // Scale up the velocity while preserving direction
                    const factor = 1.5 / currentSpeed;
                    ball.velocityX *= factor;
                    ball.velocityY *= factor;
                }
            }
            
            // Update ball physics
            function updateBall(deltaTime) {
                if (!ball || !isGameActive) return;
                
                // Update ball trail
                updateBallTrail();
                
                // Apply guidance toward target bucket
                guideBallPath();
                
                // Apply gravity
                ball.velocityY += GAME_CONFIG.gravity * deltaTime;
                
                // Update position based on velocity
                ball.x += ball.velocityX * deltaTime;
                ball.y += ball.velocityY * deltaTime;
                
                // Check for collisions with pegs
                checkPegCollisions();
                
                // Check if ball landed in a bucket
                if (checkBucketLanding()) {
                    return; // Ball landed, stop physics updates
                }
                
                // Handle wall collisions
                if (ball.x - ball.radius < 0) {
                    ball.x = ball.radius;
                    ball.velocityX = -ball.velocityX * GAME_CONFIG.speedDamping;
                    collisionHistory.push({ x: ball.x, y: ball.y, age: 0 });
                } else if (ball.x + ball.radius > canvas.width) {
                    ball.x = canvas.width - ball.radius;
                    ball.velocityX = -ball.velocityX * GAME_CONFIG.speedDamping;
                    collisionHistory.push({ x: ball.x, y: ball.y, age: 0 });
                }
                
                // Check if ball fell out of bounds
                if (ball.y - ball.radius > canvas.height) {
                    // Reset game state
                    isGameActive = false;
                    dropButton.disabled = false;
                    cancelAnimationFrame(animationFrameId);
                }
            }
            
            // Set up initial game state
            function initGame() {
                resizeCanvas();
                initPegs();
                initBuckets();
                addEventListeners();
                drawGame();
            }
            
            // Get initial ball position for reaching target bucket
            function calculateInitialBallPosition() {
                // Target bucket to aim for
                if (targetBucket === null) {
                    throw new Error("Target bucket is not set");
                }
                
                // Base position in the center
                let xPos = canvas.width / 2;
                
                // Calculate small offset based on target bucket
                // This gives the ball a slight initial bias toward the target
                const bucketOffset = targetBucket - Math.ceil(GAME_CONFIG.bucketCount / 2);
                const maxOffset = canvas.width * 0.05; // 5% of canvas width max
                const initialOffset = bucketOffset * (maxOffset / Math.ceil(GAME_CONFIG.bucketCount / 2));
                
                // Add small randomness to make it look natural
                const randomFactor = (Math.random() - 0.5) * (canvas.width * 0.02);
                xPos += initialOffset + randomFactor;
                
                // Ensure within bounds
                xPos = Math.max(GAME_CONFIG.ballRadius, Math.min(canvas.width - GAME_CONFIG.ballRadius, xPos));
                
                return xPos;
            }
            
            // Create the ball at the top of the screen
            function createBall() {
                // Clear previous state
                ballTrail = [];
                collisionHistory = [];
                
                // If random mode is selected, choose a random bucket
                if (selectedBucket === 'random') {
                    targetBucket = Math.floor(Math.random() * GAME_CONFIG.bucketCount) + 1;
                } else {
                    targetBucket = selectedBucket;
                }
                
                // Calculate starting position
                const initialX = calculateInitialBallPosition();
                
                // Create ball with initial velocity
                ball = {
                    x: initialX,
                    y: canvas.height * 0.05,
                    radius: GAME_CONFIG.ballRadius,
                    color: GAME_CONFIG.ballColor,
                    velocityX: (Math.random() - 0.5) * 1.5, // Increased initial velocity
                    velocityY: 1.0, // Add initial downward velocity
                    // Track additional state
                    targetBucket: targetBucket,
                    collisionCount: 0,
                    // For visual effects
                    rotation: 0,
                    rotationSpeed: (Math.random() - 0.5) * 0.2
                };
            }
            
            // Reset the ball to the top of the screen
            function resetBall() {
                ball = null;
                ballTrail = [];
                collisionHistory = [];
                targetBucket = null;
                isGameActive = false;
                dropButton.disabled = false;
                
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                
                drawGame();
            }
            
            // Draw the game elements on the canvas
            function drawGame() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                drawBackground();
                drawPegs();
                drawBuckets();
                drawBall();
            }
            
            // Game loop with timestamp for smooth animation
            function gameLoop(timestamp) {
                if (!lastTimestamp) {
                    lastTimestamp = timestamp;
                }
                
                // Calculate time difference between frames
                deltaTime = (timestamp - lastTimestamp) / 16; // Normalize to ~60fps
                lastTimestamp = timestamp;
                
                // Update game physics
                updateBall(deltaTime);
                
                // Draw everything
                drawGame();
                
                // Continue the loop if game is active
                if (isGameActive) {
                    animationFrameId = requestAnimationFrame(gameLoop);
                }
            }
            
            // Event handlers
            function handleBucketSelection(event) {
                if (isGameActive) return;
                
                bucketButtons.forEach(btn => btn.classList.remove('selected'));
                event.target.classList.add('selected');
                
                if (event.target.id === 'random') {
                    selectedBucket = 'random';
                } else {
                    selectedBucket = parseInt(event.target.textContent);
                }
                
                drawGame();
            }
            
            function handleDropBall() {
                if (isGameActive || selectedBucket === null) return;
                
                isGameActive = true;
                dropButton.disabled = true;
                lastTimestamp = 0;
                
                // Initialize ball and start game loop
                createBall();
                animationFrameId = requestAnimationFrame(gameLoop);
            }
            
            function handleReset() {
                resetBall();
            }
            
            function addEventListeners() {
                // Add event listeners
                bucketButtons.forEach(btn => {
                    btn.addEventListener('click', handleBucketSelection);
                });
                
                dropButton.addEventListener('click', handleDropBall);
                resetButton.addEventListener('click', handleReset);
                window.addEventListener('resize', resizeCanvas);
            }
            
            // Initialize the game
            initGame();
        });
    </script>
</body>
</html>